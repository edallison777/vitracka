name: Blue-Green Deployment

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment for blue-green deployment'
        required: true
        default: 'staging'
        type: choice
        options:
        - staging
        - production
      deployment_type:
        description: 'Type of deployment'
        required: true
        default: 'deploy'
        type: choice
        options:
        - deploy
        - rollback
        - cleanup

env:
  TF_VERSION: '1.6.0'
  AWS_REGION: 'eu-west-2'

jobs:
  blue-green-deploy:
    name: Blue-Green Deployment
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TF_VERSION }}
        
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets[format('AWS_ACCESS_KEY_ID_{0}', upper(github.event.inputs.environment))] }}
        aws-secret-access-key: ${{ secrets[format('AWS_SECRET_ACCESS_KEY_{0}', upper(github.event.inputs.environment))] }}
        aws-region: ${{ env.AWS_REGION }}
        
    - name: Determine deployment color
      id: deployment-color
      run: |
        # Get current active deployment color from AWS tags or parameter store
        CURRENT_COLOR=$(aws ssm get-parameter --name "/vitracka/${{ github.event.inputs.environment }}/active-color" --query 'Parameter.Value' --output text 2>/dev/null || echo "blue")
        
        if [ "$CURRENT_COLOR" = "blue" ]; then
          NEW_COLOR="green"
        else
          NEW_COLOR="blue"
        fi
        
        echo "current-color=$CURRENT_COLOR" >> $GITHUB_OUTPUT
        echo "new-color=$NEW_COLOR" >> $GITHUB_OUTPUT
        echo "Current active color: $CURRENT_COLOR"
        echo "Deploying to color: $NEW_COLOR"
        
    - name: Terraform Init
      run: |
        terraform init \
          -backend-config="bucket=vitracka-terraform-state-${{ github.event.inputs.environment }}" \
          -backend-config="key=terraform/${{ github.event.inputs.environment }}.tfstate" \
          -backend-config="region=${{ env.AWS_REGION }}" \
          -backend-config="dynamodb_table=vitracka-terraform-locks-${{ github.event.inputs.environment }}"
      working-directory: terraform
      
    - name: Deploy New Environment (Blue-Green)
      if: github.event.inputs.deployment_type == 'deploy'
      run: |
        # Deploy to the new color environment
        terraform plan \
          -var-file="environments/${{ github.event.inputs.environment }}.tfvars" \
          -var="deployment_color=${{ steps.deployment-color.outputs.new-color }}" \
          -var="blue_green_deployment=true" \
          -out=${{ github.event.inputs.environment }}-${{ steps.deployment-color.outputs.new-color }}.tfplan
          
        terraform apply ${{ github.event.inputs.environment }}-${{ steps.deployment-color.outputs.new-color }}.tfplan
      working-directory: terraform
      
    - name: Health Check New Environment
      if: github.event.inputs.deployment_type == 'deploy'
      run: |
        # Get the new environment endpoint
        NEW_ENDPOINT=$(terraform output -raw alb_dns_name_${{ steps.deployment-color.outputs.new-color }})
        
        # Wait for the new environment to be healthy
        echo "Checking health of new environment: $NEW_ENDPOINT"
        
        for i in {1..30}; do
          if curl -f -s "http://$NEW_ENDPOINT/health" > /dev/null; then
            echo "Health check passed for new environment"
            break
          fi
          
          if [ $i -eq 30 ]; then
            echo "Health check failed for new environment"
            exit 1
          fi
          
          echo "Waiting for new environment to be healthy... (attempt $i/30)"
          sleep 30
        done
      working-directory: terraform
      
    - name: Switch Traffic to New Environment
      if: github.event.inputs.deployment_type == 'deploy'
      run: |
        # Update Route 53 or ALB target groups to point to new environment
        # This is a simplified example - actual implementation would depend on your routing setup
        
        # Update the active color parameter
        aws ssm put-parameter \
          --name "/vitracka/${{ github.event.inputs.environment }}/active-color" \
          --value "${{ steps.deployment-color.outputs.new-color }}" \
          --overwrite
          
        # Update ALB listener rules to route traffic to new target group
        NEW_TARGET_GROUP_ARN=$(terraform output -raw target_group_arn_${{ steps.deployment-color.outputs.new-color }})
        LISTENER_ARN=$(terraform output -raw alb_listener_arn)
        
        aws elbv2 modify-listener \
          --listener-arn $LISTENER_ARN \
          --default-actions Type=forward,TargetGroupArn=$NEW_TARGET_GROUP_ARN
          
        echo "Traffic switched to ${{ steps.deployment-color.outputs.new-color }} environment"
      working-directory: terraform
      
    - name: Verify New Environment
      if: github.event.inputs.deployment_type == 'deploy'
      run: |
        # Run smoke tests against the new environment
        echo "Running smoke tests against new environment..."
        
        # Get the main endpoint (should now point to new environment)
        MAIN_ENDPOINT=$(terraform output -raw alb_dns_name)
        
        # Basic health check
        curl -f "http://$MAIN_ENDPOINT/health"
        
        # Additional smoke tests can be added here
        echo "Smoke tests passed"
      working-directory: terraform
      
    - name: Rollback Deployment
      if: github.event.inputs.deployment_type == 'rollback'
      run: |
        echo "Rolling back to ${{ steps.deployment-color.outputs.current-color }} environment"
        
        # Switch traffic back to previous environment
        PREVIOUS_TARGET_GROUP_ARN=$(terraform output -raw target_group_arn_${{ steps.deployment-color.outputs.current-color }})
        LISTENER_ARN=$(terraform output -raw alb_listener_arn)
        
        aws elbv2 modify-listener \
          --listener-arn $LISTENER_ARN \
          --default-actions Type=forward,TargetGroupArn=$PREVIOUS_TARGET_GROUP_ARN
          
        # Update the active color parameter back
        aws ssm put-parameter \
          --name "/vitracka/${{ github.event.inputs.environment }}/active-color" \
          --value "${{ steps.deployment-color.outputs.current-color }}" \
          --overwrite
          
        echo "Rollback completed"
      working-directory: terraform
      
    - name: Cleanup Old Environment
      if: github.event.inputs.deployment_type == 'cleanup'
      run: |
        echo "Cleaning up ${{ steps.deployment-color.outputs.current-color }} environment"
        
        # Destroy the inactive environment to save costs
        terraform plan \
          -var-file="environments/${{ github.event.inputs.environment }}.tfvars" \
          -var="deployment_color=${{ steps.deployment-color.outputs.current-color }}" \
          -var="blue_green_deployment=true" \
          -destroy \
          -out=cleanup-${{ steps.deployment-color.outputs.current-color }}.tfplan
          
        terraform apply cleanup-${{ steps.deployment-color.outputs.current-color }}.tfplan
        
        echo "Cleanup completed"
      working-directory: terraform
      
    - name: Notify Deployment Status
      if: always()
      run: |
        if [ "${{ job.status }}" = "success" ]; then
          echo "✅ Blue-Green deployment completed successfully"
          echo "Active environment: ${{ steps.deployment-color.outputs.new-color }}"
        else
          echo "❌ Blue-Green deployment failed"
          echo "Active environment: ${{ steps.deployment-color.outputs.current-color }}"
        fi
        
        # Here you could add Slack/Teams notifications, etc.